"""Compile per-client Typst notices into PDFs sequentially.

This lightweight helper keeps the compilation step in Python so future
enhancements (parallel workers, structured logging) can be layered on in a
follow-up. For now it mirrors the behaviour of the original shell script.

**Input Contract:**
- Reads Typst template files from output/artifacts/typst/
- Assumes .typ files are valid Typst templates (generated by generate_notices step)
- Assumes typst compiler binary is available (configured in parameters.yaml)

**Output Contract:**
- Writes compiled PDF files to output/pdf_individual/
- All .typ files must compile successfully (critical step; fail-fast)
- Filenames match input .typ files with .pdf extension

**Error Handling:**
- Typst compilation errors raise immediately (subprocess check=True)
- Missing .typ files raise immediately (fail-fast)
- No per-file recovery; all-or-nothing output (critical feature)

**Validation Contract:**

What this module validates:
- All .typ files in artifact/typst/ can be discovered
- Typst compiler exists at configured path (or default 'typst')
- Typst compiler exits with success (exit code 0)
- Font paths are accessible (if configured)

What this module assumes (validated upstream):
- .typ files are valid Typst templates (validated by generate_notices step)
- Output directory can be created (general I/O)
- typst.bin and typst.font_path config keys are valid (from load_config)

Note: This is a critical step. Compilation failure halts pipeline (fail-fast).
"""

from __future__ import annotations

import os
import subprocess
from pathlib import Path

from .config_loader import load_config

ROOT_DIR = Path(__file__).resolve().parent.parent


def discover_typst_files(artifact_dir: Path) -> list[Path]:
    """Discover all Typst template files in the artifact directory.

    Parameters
    ----------
    artifact_dir : Path
        Directory containing pipeline artifacts (should have a 'typst' subdirectory).

    Returns
    -------
    list[Path]
        Sorted list of Typst (.typ) file paths, or empty list if directory doesn't exist.
    """
    typst_dir = artifact_dir / "typst"
    if not typst_dir.exists():
        return []
    return sorted(typst_dir.glob("*.typ"))


def compile_file(
    typ_path: Path,
    pdf_dir: Path,
    *,
    typst_bin: str,
    font_path: Path | None,
    root_dir: Path,
    verbose: bool,
) -> None:
    """Compile a single Typst template file to PDF.

    Parameters
    ----------
    typ_path : Path
        Path to the .typ Typst template file to compile.
    pdf_dir : Path
        Directory where the compiled PDF should be written.
    typst_bin : str
        Path or name of the typst binary to use for compilation.
    font_path : Path | None
        Optional path to directory containing custom fonts.
    root_dir : Path
        Root directory for relative path resolution in Typst compilation.
    verbose : bool
        If True, print compilation status message.
    """
    pdf_path = pdf_dir / f"{typ_path.stem}.pdf"
    command = [typst_bin, "compile"]
    if font_path:
        command.extend(["--font-path", str(font_path)])
    command.extend(["--root", str(root_dir), str(typ_path), str(pdf_path)])
    subprocess.run(command, check=True)
    if verbose:
        print(f"Compiled {typ_path.name} -> {pdf_path.name}")


def compile_typst_files(
    artifact_dir: Path,
    pdf_dir: Path,
    *,
    typst_bin: str,
    font_path: Path | None,
    root_dir: Path,
    verbose: bool,
) -> int:
    """Compile all discovered Typst template files sequentially to PDFs.

    Parameters
    ----------
    artifact_dir : Path
        Directory containing Typst artifacts.
    pdf_dir : Path
        Output directory for compiled PDFs.
    typst_bin : str
        Path or name of the typst binary.
    font_path : Path | None
        Optional custom fonts directory.
    root_dir : Path
        Root directory for relative path resolution.
    verbose : bool
        If True, print per-file compilation status.

    Returns
    -------
    int
        Number of files successfully compiled.
    """
    pdf_dir.mkdir(parents=True, exist_ok=True)
    typ_files = discover_typst_files(artifact_dir)
    if not typ_files:
        print(f"No Typst artifacts found in {artifact_dir}.")
        return 0

    for typ_path in typ_files:
        compile_file(
            typ_path,
            pdf_dir,
            typst_bin=typst_bin,
            font_path=font_path,
            root_dir=root_dir,
            verbose=verbose,
        )
    return len(typ_files)


def compile_with_config(
    artifact_dir: Path,
    output_dir: Path,
    config_path: Path | None = None,
) -> int:
    """Compile Typst files using configuration from parameters.yaml.

    Parameters
    ----------
    artifact_dir : Path
        Directory containing Typst artifacts (.typ files).
    output_dir : Path
        Directory where compiled PDFs will be written.
    config_path : Path, optional
        Path to parameters.yaml. If not provided, uses default location.

    Returns
    -------
    int
        Number of files compiled.
    """
    config = load_config(config_path)

    typst_config = config.get("typst", {})
    font_path_str = typst_config.get("font_path", "/usr/share/fonts/truetype/freefont/")
    typst_bin = typst_config.get("bin", "typst")

    # Allow TYPST_BIN environment variable to override config
    typst_bin = os.environ.get("TYPST_BIN", typst_bin)

    font_path = Path(font_path_str) if font_path_str else None

    return compile_typst_files(
        artifact_dir,
        output_dir,
        typst_bin=typst_bin,
        font_path=font_path,
        root_dir=ROOT_DIR,
        verbose=False,
    )


def main(artifact_dir: Path, output_dir: Path, config_path: Path | None = None) -> int:
    """Main entry point for Typst compilation.

    Parameters
    ----------
    artifact_dir : Path
        Directory containing Typst artifacts.
    output_dir : Path
        Directory for output PDFs.
    config_path : Path, optional
        Path to parameters.yaml configuration file.

    Returns
    -------
    int
        Number of files compiled.
    """
    compiled = compile_with_config(artifact_dir, output_dir, config_path)
    if compiled:
        print(f"Compiled {compiled} Typst file(s) to PDFs in {output_dir}.")
    return compiled


if __name__ == "__main__":
    import sys

    print(
        "⚠️  Direct invocation: This module is typically executed via orchestrator.py.\n"
        "   Re-running a single step is valid when pipeline artifacts are retained on disk,\n"
        "   allowing you to skip earlier steps and regenerate output.\n"
        "   Note: Output will overwrite any previous files.\n"
        "\n"
        "   For typical usage, run: uv run viper <input> <language>\n",
        file=sys.stderr,
    )
    sys.exit(1)
